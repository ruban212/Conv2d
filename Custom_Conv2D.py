# -*- coding: utf-8 -*-
"""Conv2d_layers .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WgR-ltuNBooUPyD6ZxC86Eh3vmcR3E7S
"""

import torch
import torch.nn as nn
import torch.nn.functional as F

class RubanConv2D(nn.Module):
    def __init__(self, kernel, stride=1, padding=0):
        super(RubanConv2D, self).__init__()
        self.kernel = kernel
        self.stride = stride
        self.padding = padding

    def forward(self, input_matrix):
        if self.padding > 0:
            input_pad = F.pad(input_matrix, (self.padding, self.padding, self.padding, self.padding), mode='constant')
        else:
            input_pad = input_matrix

        input_height, input_width = input_pad.shape
        kernel_height, kernel_width = self.kernel.shape

        output_height = (input_height - kernel_height) // self.stride + 1
        output_width = (input_width - kernel_width) // self.stride + 1

        output_matrix = torch.zeros((output_height, output_width), dtype=input_matrix.dtype)

        for i in range(0, output_height):
            for j in range(0, output_width):
                region = input_pad[..., i*self.stride:i*self.stride+kernel_height, j*self.stride:j*self.stride+kernel_width]
                output_matrix[i, j] = torch.sum(region * self.kernel)

        return output_matrix